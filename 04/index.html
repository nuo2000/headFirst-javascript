<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>Phrase-o-matic</title>
</head>
<body>
<!--4 让数据排排坐
    数组
-->

</body>
<script>
    /*
* 数组是一种按照顺序存储数据的数据结构可存储很多值的JavaScript数据类型，可将这些值视为一个整体，也可在需要时访问其中的各个值。数组格式：数组变量名 赋值符= 使用字符[指定数组开始的位置 所有数组元素(值) 使用字符]指定数组的结束位置。数组中元素排列的顺序在大多数情况下都很重要。要获取最后一个元素的索引可将数组的长度-1
* 例如：var list = ["一",2,true]
* 访问数组的元素语法：数组变量名 方括号括起的索引(打印出来是索引号的值不是索引号)。如果访问索引太大或太小(如小于0或不存在的索引)的数组元素得到结果undefined。
* 索引(index)：从0开始，第一个数组元素索引为[0]
* 试图访问不存在的元素将返回undefined 给既有元素赋值将修改元素的值 给不存在的元素赋值将在数组中新建一个元素
* 修改数组元素语法：数组变量名[索引号]=值
* 添加数组元素语法：两种方法：指定索引、push方法无需指定索引。第一种：数组变量名[索引号]=值。第二种： 数组变量名句点push属性(值)
* 获取数组长度：数组变量名句点和属性length。利用索引0来获取数组第1个元素，利用属性length-1来获取最后一个数组元素，属性length总是比数组的最后一个索引大1，获取数组长度减1。myArray[myArray.length-1];
* 一个数组中可存储元素受制于计算机的内存量，可达到数千个。可以创建空数组(它不包含任何元素，长度为零,是一个数组字面量)以后添加元素。数组中几乎可以存储任何JavaScript值，包括数字、字符串、布尔值、其他数组、对象。一个数组中所有的值得类型不用必须相同，但通常存储相同的值。
* 稀疏数组是有些索引处有值，而其他索引处没有值的数组。创建稀疏数组：var sparseArray = []; sparseArray[0]=true;sparseArray[100]=true; 没有值的索引处值都为undefined 其他创建数组的方式 var myarray = new Array(3);
* 检查元素的值是不是undefined可编写 if (myarray[i] === undefined){...}
* 字面量：表示如何表达这个值，一般除去表达式。给变量赋值时，等号右边的都可以认为是字面量。分为：字符串字面量(stringLiteral)数组字面量(arrayLiteral)对象字面量(objectLiteral),函数字面量(functionLiteral)。例： var test="hello world!"; "hello world!"就是字符串字面量
* for循环：以关键字for打头 圆括号中有3部分 第一部分是初始化循环变量只在循环开始前执行一次。第二部分是条件测试，每次循环时都将执行该测试，如果为false就结束循环。第三部分将计数器+1每次循环都这样做，执行完循环体的所有语句后进行。 for循环最常用于知道循环需要执行多少次时
* 后递增运算符++ 变量名++ 语句执行后比原来大1(常用于for语句中)。后递减运算符 变量名-- 语句执行后比原来小1 可以用;来省略for循环的条件 比如：for(;answer != "forty-two";)
* 重构(refactor)指的是在不改变代码功能的情况下，对其进行重新组织，使其更易于理解和维护。
* 稀疏数组指的是中间有值为undefined的元素的数组
* 两个数组的数据是对应关系都位于相同索引处这样的数组叫做平行数组
*
*
*
* */
</script>
<script type="text/html">
    //创建数组
    var scores = [60, 50, 60, 58, 54, 54, 58, 50, 52, 54];

    //访问数组
    var solution2 = scores[2];
    alert("Solution 2 produced " + solution2 + " bubbles.");

    var flavors = ["vanilla", "butterscotch", "lavender", "chocolate", "cookie dough", {}];

    var flavorOfTheDay = flavors[2];

    //修改数组元素
    flavors[3] = "vanilla";
    //修改添加数组元素(给数组内的对象加属性)
    flavors[5].fragrance = flavorOfTheDay;
    //获取数组长度
    var numFlavors = flavors.length;
    console.log(numFlavors);

</script>

<script type="text/html">
    //定义函数 调用函数后执行
    function makePhrases() {
    var words1 = ["24/7", "multi-tier", "30,000 foot", "B-to-B", "win-win"];
    var words2 = ["empowered", "value-added", "oriented", "focused", "aligned"];
    var words3 = ["process", "solution", "tipping-point", "strategy", "vision"];

    //Math.random生成一个0~1(不包括1)的数字，将其乘以数组的长度，并使用Math.floor将结果向下圆整。(得到一个位于0和数组长度减1之间的整数)
    var rand1 = Math.floor(Math.random() * words1.length);
    var rand2 = Math.floor(Math.random() * words2.length);
    var rand3 = Math.floor(Math.random() * words3.length);
    //随机的访问数组中某个索引号元素
    //words1[rand1] 数组名索引
    var phrase = words1[rand1] + " " + words2[rand2] + " " + words3[rand3];
    alert(phrase);
    }

    //调用函数
    makePhrases();

</script>
<script>
    var scores = [
        60, 50, 60, 58, 54, 54,
        58, 50, 52, 54, 48, 69,
        34, 55, 51, 52, 44, 51,
        69, 64, 66, 55, 52, 61,
        46, 31, 57, 52, 44, 18,
        41, 53, 55, 61, 51, 44];

    /*
    //判断数组中元素的值中有没有undefined
    for (var i = 0; i < scores.length; i++) {
        if (scores[i] == undefined) {
            console.log("有undefined")
        } else {
            console.log("没有undefined")
        }
    }

    //新建数组包含3个空位置 长度为3不包含任何值 元素的值都是undefined
    var myarray = new Array(3);
    console.log(myarray);

    var genres = [];
    //索引号添加元素
    genres[0] = "Rockabilly";
    genres[1] = "Ambient";
    var size = genres.length;
    console.log(size);

    var genres = [];
    //push添加元素(在数组末尾添加一个新元素)
    genres.push("Rockabilly");
    genres.push("Ambient");
    var size = genres.length;
    console.log(size);

    var myImportantCounter = myImportantCounter + 1;
    //后递增运算符(post-increment operator)
    myImportantCounter++;
    */

    /*var output;
    var highScore = 0;

    var i = 0;
    while (i < scores.length) {
        output = "Bubble solution #" + i + " score:" +
            scores[i];
        console.log(output);
        if (scores[i] > highScore) {
            highScore = scores[i];
        }
        //调用全局变量i并赋值
        i = i + 1;
    }
    var e = 0;
    var bestSolutions = [];
    while (e < scores.length) {
        if (scores[e] == highScore) {
            bestSolutions.push(e);
        }
        e = e + 1;
    }
    console.log("Bubbles tests：" + scores.length);
    console.log("Highest bubble score: " + highScore);
    console.log("Solutions with highest score: " + bestSolutions);*/

    /*var output;
    var highScore = 0;

    for (var i = 0; i < scores.length; i++) {
        output = "Bubble solution #" + i + " score:" +
            scores[i];
        console.log(output);

        if (scores[i] > highScore) {
            highScore = scores[i];
        }
    }
    var testsLength = scores.length;
    console.log(testsLength);
    console.log("Highest bubble score: " + highScore);

    var bestSolutions = [];
    for (var i = 0; i < scores.length; i++) {

        if (scores[i] == highScore) {
            bestSolutions.push(i);
        }
    }
    console.log("Solutions with highest score: " + bestSolutions);*/

    //重构代码
    function printAndGetHighScore(scores) {
        var highScore = 0;
        var output;
        for (var i = 0; i < scores.length; i++) {
            output = "Bubble solution #" + i + "score: " + scores[i];
            console.log(output);
            if (scores[i] > highScore) {
                highScore = scores[i];
            }
        }
        return highScore;
    }

    //调用函数 传入数组 返回的值赋给变量
    var highScore = printAndGetHighScore(scores);

    function getBestResults(scores, highScore) {
        var bestSolutions = [];
        for (var i = 0; i < scores.length; i++) {
            if (scores[i] == highScore) {
                bestSolutions.push(i);
            }
        }
        return bestSolutions;
    }

    var bestSolutions = getBestResults(scores, highScore);
    console.log("Solutions with highest score: " + bestSolutions);

    //数组添加元素
    /*var products = ["Choo Choo Chocolate", "Icy Mint", "Cake Batter", "Bubblegum"];
    var hasBubbleGum = [false, false, false, true];
    var i = 0;
    while (i < hasBubbleGum.length) {
        if (hasBubbleGum[i]) {
            console.log(products[i] + " contains bubble gum");
        }
        i = i + 1;
    }*/
    /* var hasBubbleGum = [false,
         false,
         false,
         true];

     var products = ["Choo Choo Chocolate",
         "Icy Mint", "Cake Batter",
         "Bubblegum"];

     for (var i = 0; i < hasBubbleGum.length; i = i + 1) {

         if (hasBubbleGum[i]) {
             console.log(products[i] + " contains bubble gum")
         }
     }*/

    var costs = [
        .25, .27, .25, .25, .25, .25,
        .33, .31, .25, .29, .27, .22,
        .31, .25, .25, .33, .21, .25,
        .25, .25, .28, .25, .24, .22,
        .20, .25, .30, .25, .24, .25,
        .25, .25, .27, .25, .26, .29];

    function getMostCostEffectiveSolution(scores, costs, highscore) {
        var cost = 100;
        var index;
        for (var i = 0; i < scores.length; i++) {
            if (scores[i] == highscore) {
                if (cost > costs[i]) {
                    index = i;
                    cost = costs[i];
                }
            }
        }
        return index;
    }

    var mostCostEffective = getMostCostEffectiveSolution(scores, costs, highScore);
    console.log("Bubble Solution #" + mostCostEffective + " is the most cost effective");
</script>
<script>
    var scores = [60, 50, 60, 58, 54, 54,
        58, 50, 52, 54, 48, 69,
        34, 55, 51, 52, 44, 51,
        69, 64, 66, 55, 52, 61,
        46, 31, 57, 52, 44, 18,
        41, 53, 55, 61, 51, 44];
    var costs = [.25, .27, .25, .25, .25, .25, .33, .31,
        .25, .29, .27, .22, .31, .25, .25, .33,
        .21, .25, .25, .25, .28, .25, .24, .22,
        .20, .25, .30, .25, .24, .25, .25, .25,
        .27, .25, .26, .29];

    var highScore, bestSolutions;

    //
    // compute the high score and display results
    //
    highScore = printAndGetHighScore(scores);
    console.log("Bubbles tests: " + scores.length);
    console.log("Highest bubble score: " + highScore);

    //
    // compute the best solutions and display
    //
    bestSolutions = getBestResults(scores, highScore);
    console.log("Solutions with the highest score: " + bestSolutions);

    //
    // compute the most cost effective of the best solutions
    //
    mostCostEffective = getMostCostEffectiveSolution(scores, costs, highScore);

    // or use the more efficient function:
    //mostCostEffective = getMostCostEffectiveSolution2(bestSolutions, costs);

    // display the results
    console.log("Bubble Solution #" + mostCostEffective + " is the most cost effective");

    function printAndGetHighScore(scores) {
        var highScore = 0;
        var output;
        for (var i = 0; i < scores.length; i++) {
            output = "Bubble solution #" + i + " score: " + scores[i];
            console.log(output);
            if (scores[i] > highScore) {
                highScore = scores[i];
            }
        }
        return highScore;
    }

    function getBestResults(scores, highScore) {
        var bestSolutions = [];
        for (var i = 0; i < scores.length; i++) {
            if (scores[i] == highScore) {
                bestSolutions.push(i);
            }
        }
        return bestSolutions;
    }


    function getMostCostEffectiveSolution(scores, costs, highScore) {
        var cost = 100; // much higher than any of the costs
        var index;

        for (var i = 0; i < scores.length; i++) {
            if (scores[i] == highScore) {
                if (cost > costs[i]) {
                    index = i;
                    cost = costs[i];
                }
            }
        }
        return index;
    }

    //
    // Another way to write this is to use the bestSolutions array,
    // and use the index stored there to find the cost value of that solution.
    // This is a little more efficient, but not quite as easy to read!
    //
    function getMostCostEffectiveSolution2(bestSolutions, costs) {
        var cost = 100;
        var solutionIndex;
        var lowCostIndex;

        for (var i = 0; i < bestSolutions.length; i++) {
            solutionIndex = bestSolutions[i];
            if (cost > costs[solutionIndex]) {
                lowCostIndex = solutionIndex;
                cost = costs[solutionIndex];
            }
        }
        return lowCostIndex;
    }
</script>
</html>